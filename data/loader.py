# -*- coding: utf-8 -*-
"""loader.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eLlV-tGatahS-aWTD6jNJGvfkt0dfhhP
"""

import os
import zipfile
import numpy as np
import pandas as pd
from glob import glob
from tqdm import tqdm
import urllib.request

def download_and_prepare_openfield():
    os.makedirs("datasets", exist_ok=True)
    url = "https://zenodo.org/record/8186065/files/data.zip"
    zip_path = "datasets/data.zip"

    if not os.path.exists(zip_path):
        print("Downloading ETH OpenField dataset...")
        urllib.request.urlretrieve(url, zip_path)

    extract_path = "datasets/openfield"
    if not os.path.exists(os.path.join(extract_path, "data")):
        print("Extracting dataset...")
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_path)

def load_openfield_sequences(seq_len=30):
    base_path = "datasets/openfield/data"
    csv_files = sorted(glob(os.path.join(base_path, "**/*.csv"), recursive=True))
    X_all, y_all = [], []

    for fpath in tqdm(csv_files, desc="Parsing pose files"):
        try:
            df = pd.read_csv(fpath, header=[0, 1, 2])
            df.columns = df.columns.droplevel(0)

            bodyparts = df.columns.levels[0]
            coords = ['x', 'y']
            keypoints = []
            for bp in bodyparts:
                for coord in coords:
                    if (bp, coord) in df.columns:
                        keypoints.append(df[bp][coord].values)
            keypoints = np.array(keypoints).T

            if keypoints.shape[0] < seq_len:
                continue

            for kp in ["nose", "centre", "bodycentre", "tailbase"]:
                if (kp, "x") in df.columns and (kp, "y") in df.columns:
                    motion_x = df[kp]["x"].values
                    motion_y = df[kp]["y"].values
                    break
            else:
                print(f"{os.path.basename(fpath)}: no motion keypoint found")
                continue

            speed = np.sqrt(np.diff(motion_x)**2 + np.diff(motion_y)**2)
            label_seq = (speed > 5).astype(int)
            label_seq = np.pad(label_seq, (1, 0), mode='constant')

            for i in range(len(label_seq) - seq_len):
                X_all.append(keypoints[i:i+seq_len])
                y_all.append(int(np.mean(label_seq[i:i+seq_len]) > 0.5))

        except Exception as e:
            print(f"Could not process {os.path.basename(fpath)}: {e}")

    X = np.array(X_all)
    y = np.array(y_all)
    print(f"Loaded {len(X)} sequences of shape {X.shape[1:]} with labels {np.unique(y)}")
    return X, y